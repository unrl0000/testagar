<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dipper.io</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: sans-serif; }
        canvas { display: block; background-color: #e0e0e0; }
        #disconnect-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 1.5em;
            display: none; /* Hidden by default */
            text-align: center;
        }
         #scoreboard {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0,0,0,0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            min-width: 150px;
         }
         #scoreboard h3 { margin: 0 0 5px 0; }
         #scoreboard ul { list-style: none; padding: 0; margin: 0; }
         #scoreboard li { margin-bottom: 3px; }

    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="disconnect-message">
        Disconnected from server.<br>Please refresh the page.
    </div>
     <div id="scoreboard">
        <h3>Scoreboard</h3>
        <ul id="score-list"></ul>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const disconnectMessage = document.getElementById('disconnect-message');
        const scoreList = document.getElementById('score-list');


        // --- Constants (match server if needed, or client-specific) ---
        const PLAYER_RADIUS = 20;
        const BULLET_RADIUS = 8;
        const TURRET_LENGTH = PLAYER_RADIUS * 1.4;
        const TURRET_WIDTH = 10;
        const HEALTH_BAR_WIDTH = 40;
        const HEALTH_BAR_HEIGHT = 5;
        const MAP_WIDTH = 2000; // Should match server
        const MAP_HEIGHT = 2000; // Should match server


        // --- Game State (Client Side) ---
        let players = {}; // { id: { x, y, angle, health, maxHealth, score, color, dead } }
        let bullets = {}; // { id: { x, y } }
        let myPlayerId = null;
        let ws = null;
        let connected = false;
        let cameraX = 0;
        let cameraY = 0;

        // --- Input State ---
        const keys = { w: false, a: false, s: false, d: false };
        let mouseX = 0;
        let mouseY = 0;
        let isShooting = false;
        let lastSentAngle = 0;
        let lastSentInput = {};

        // --- Utility Functions ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // --- Drawing Functions ---
        function drawPlayer(player) {
             if (player.dead) return; // Don't draw dead players explicitly, maybe a marker later

            const screenX = player.x - cameraX + canvas.width / 2;
            const screenY = player.y - cameraY + canvas.height / 2;

            // Draw body
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(screenX, screenY, PLAYER_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw turret
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(player.angle);
            ctx.fillStyle = '#999';
            ctx.fillRect(0, -TURRET_WIDTH / 2, TURRET_LENGTH, TURRET_WIDTH);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, -TURRET_WIDTH / 2, TURRET_LENGTH, TURRET_WIDTH);
            ctx.restore();

            // Draw health bar
            const healthPercentage = player.health / player.maxHealth;
            const healthBarX = screenX - HEALTH_BAR_WIDTH / 2;
            const healthBarY = screenY - PLAYER_RADIUS - HEALTH_BAR_HEIGHT - 5;

            ctx.fillStyle = '#ddd'; // Background
            ctx.fillRect(healthBarX, healthBarY, HEALTH_BAR_WIDTH, HEALTH_BAR_HEIGHT);
            ctx.fillStyle = healthPercentage > 0.5 ? '#00cc00' : healthPercentage > 0.2 ? '#cccc00' : '#cc0000'; // Health color
            ctx.fillRect(healthBarX, healthBarY, HEALTH_BAR_WIDTH * healthPercentage, HEALTH_BAR_HEIGHT);
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            ctx.strokeRect(healthBarX, healthBarY, HEALTH_BAR_WIDTH, HEALTH_BAR_HEIGHT);

             // Draw score or name (optional)
            ctx.fillStyle = 'black';
            ctx.textAlign = 'center';
            ctx.font = '12px sans-serif';
            // Simple ID display for now
            ctx.fillText(`P:${player.id.split('_')[1]} (${player.score})`, screenX, screenY + PLAYER_RADIUS + 15);


             // Indicate own player
             if (player.id === myPlayerId) {
                 ctx.strokeStyle = 'gold';
                 ctx.lineWidth = 3;
                 ctx.beginPath();
                 ctx.arc(screenX, screenY, PLAYER_RADIUS + 5, 0, Math.PI * 2);
                 ctx.stroke();
             }
        }

        function drawBullet(bullet) {
            const screenX = bullet.x - cameraX + canvas.width / 2;
            const screenY = bullet.y - cameraY + canvas.height / 2;

            ctx.fillStyle = '#555'; // Bullet color
            ctx.beginPath();
            ctx.arc(screenX, screenY, BULLET_RADIUS, 0, Math.PI * 2);
            ctx.fill();
        }

         function drawMapBoundary() {
            const mapStartX = -cameraX + canvas.width / 2;
            const mapStartY = -cameraY + canvas.height / 2;
            const mapEndX = MAP_WIDTH - cameraX + canvas.width / 2;
            const mapEndY = MAP_HEIGHT - cameraY + canvas.height / 2;

            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 5;
            ctx.strokeRect(mapStartX, mapStartY, MAP_WIDTH, MAP_HEIGHT);
         }

        function updateScoreboard() {
            const sortedPlayers = Object.values(players)
                .filter(p => !p.dead) // Only show living players maybe? Or sort dead lower?
                .sort((a, b) => b.score - a.score)
                .slice(0, 10); // Show top 10

            scoreList.innerHTML = ''; // Clear previous list
            sortedPlayers.forEach(player => {
                const li = document.createElement('li');
                // Simple ID display for now
                li.textContent = `P:${player.id.split('_')[1]} - ${player.score}`;
                if(player.id === myPlayerId) {
                   li.style.fontWeight = 'bold';
                   li.style.color = 'gold';
                }
                scoreList.appendChild(li);
            });
        }

        // --- Game Loop (Client) ---
        function gameLoop() {
            if (!connected || !myPlayerId) {
                requestAnimationFrame(gameLoop); // Keep trying if not connected yet
                return;
            }

            // --- Update Logic ---
            const myPlayer = players[myPlayerId];

            // Calculate angle towards mouse
            if (myPlayer && !myPlayer.dead) {
                const screenX = myPlayer.x - cameraX + canvas.width / 2;
                const screenY = myPlayer.y - cameraY + canvas.height / 2;
                const angle = Math.atan2(mouseY - screenY, mouseX - screenX);

                // Send angle update if changed significantly
                if (Math.abs(angle - lastSentAngle) > 0.05) { // Threshold to reduce network traffic
                     send({ type: 'angle', angle: angle });
                     lastSentAngle = angle; // Store the actually sent angle
                }

                // Center camera on player
                cameraX = myPlayer.x;
                cameraY = myPlayer.y;
            } else if(myPlayer && myPlayer.dead) {
               // Maybe slowly pan camera or show death message
            } else {
                 // If player data not yet received, center camera at 0,0
                 cameraX = MAP_WIDTH / 2;
                 cameraY = MAP_HEIGHT / 2;
            }


            // --- Rendering ---
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw map boundaries (optional)
             drawMapBoundary();

            // Draw bullets first (under players)
            for (const bulletId in bullets) {
                drawBullet(bullets[bulletId]);
            }

            // Draw players
            const playerIds = Object.keys(players).sort((a, b) => {
                 // Draw own player last (on top)
                 if (a === myPlayerId) return 1;
                 if (b === myPlayerId) return -1;
                 return 0;
            });

            playerIds.forEach(playerId => {
                 drawPlayer(players[playerId]);
            });


            // Update scoreboard
            updateScoreboard();

            // Request next frame
            requestAnimationFrame(gameLoop);
        }

        // --- WebSocket Communication ---
        function connectWebSocket() {
            // Use wss:// if the main page is served over https, otherwise ws://
            const wsProtocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
            const wsUrl = `${wsProtocol}${window.location.host}`; // Connect to the same host serving the HTML

            console.log(`Connecting to WebSocket: ${wsUrl}`);
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connection established.');
                connected = true;
                disconnectMessage.style.display = 'none'; // Hide disconnect message
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    // console.log('Received:', data.type); // Debugging

                    switch (data.type) {
                        case 'welcome':
                            myPlayerId = data.playerId;
                            players = data.initialState.players || {}; // Load initial state
                            bullets = data.initialState.bullets || {};
                            console.log(`Assigned Player ID: ${myPlayerId}`);
                            break;
                        case 'update':
                            // Simple state replacement - could be optimized later
                            players = data.players || {};
                            bullets = data.bullets || {};
                            break;
                         case 'playerJoined':
                            if(data.player && data.player.id !== myPlayerId) {
                               players[data.player.id] = data.player;
                               console.log(`Player ${data.player.id} joined`);
                            }
                             break;
                        case 'playerLeft':
                            delete players[data.playerId];
                            console.log(`Player ${data.playerId} left`);
                            break;
                         case 'playerDied':
                             console.log(`Player ${data.playerId} died.`);
                             if (players[data.playerId]) {
                                 players[data.playerId].dead = true; // Mark as dead visually
                                 players[data.playerId].health = 0; // Ensure health is 0
                             }
                             // Could show a message if killerId === myPlayerId
                             break;
                        // Add other message types as needed (e.g., specific events)
                    }
                } catch (error) {
                    console.error('Failed to parse message or invalid message format:', event.data, error);
                }
            };

            ws.onclose = () => {
                console.log('WebSocket connection closed.');
                connected = false;
                myPlayerId = null;
                players = {};
                bullets = {};
                disconnectMessage.style.display = 'block'; // Show disconnect message
                // Optionally attempt to reconnect after a delay
                // setTimeout(connectWebSocket, 5000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                // ws.onclose will likely be called after this
                 disconnectMessage.style.display = 'block'; // Show disconnect message early
            };
        }

        function send(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(data));
            }
        }

        // --- Input Event Listeners ---
        function handleKeyDown(event) {
            let inputChanged = false;
            switch (event.key.toLowerCase()) {
                case 'w': case 'arrowup':    if (!keys.w) { keys.w = true; inputChanged = true; } break;
                case 'a': case 'arrowleft':  if (!keys.a) { keys.a = true; inputChanged = true; } break;
                case 's': case 'arrowdown':  if (!keys.s) { keys.s = true; inputChanged = true; } break;
                case 'd': case 'arrowright': if (!keys.d) { keys.d = true; inputChanged = true; } break;
                case ' ': // Shoot with spacebar
                    if (!isShooting) {
                       isShooting = true;
                       send({ type: 'shoot' });
                       // Add client-side cooldown visualization if needed
                    }
                    break;
            }
            if (inputChanged) {
                // Send input only if it actually changed
                 const currentInput = { up: keys.w, down: keys.s, left: keys.a, right: keys.d };
                 if (JSON.stringify(currentInput) !== JSON.stringify(lastSentInput)) {
                     send({ type: 'input', input: currentInput });
                     lastSentInput = currentInput;
                 }
            }
        }

        function handleKeyUp(event) {
             let inputChanged = false;
            switch (event.key.toLowerCase()) {
                case 'w': case 'arrowup':    if (keys.w) { keys.w = false; inputChanged = true; } break;
                case 'a': case 'arrowleft':  if (keys.a) { keys.a = false; inputChanged = true; } break;
                case 's': case 'arrowdown':  if (keys.s) { keys.s = false; inputChanged = true; } break;
                case 'd': case 'arrowright': if (keys.d) { keys.d = false; inputChanged = true; } break;
                 case ' ':
                    isShooting = false;
                    break;
            }
             if (inputChanged) {
                  const currentInput = { up: keys.w, down: keys.s, left: keys.a, right: keys.d };
                  send({ type: 'input', input: currentInput });
                  lastSentInput = currentInput;
             }
        }

        function handleMouseMove(event) {
            mouseX = event.clientX;
            mouseY = event.clientY;
            // Angle calculation and sending is handled in the game loop to use player position
        }

        function handleMouseDown(event) {
            // Left mouse button for shooting
            if (event.button === 0) {
                send({ type: 'shoot' });
                 // Client-side throttling could be added here too,
                 // but server already has cooldown
            }
        }

        // --- Initialization ---
        window.addEventListener('resize', resizeCanvas);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mousedown', handleMouseDown); // Use mousedown for continuous shooting if held

        resizeCanvas();
        connectWebSocket();
        gameLoop(); // Start the client-side rendering loop

    </script>
</body>
</html>
